Instructions for translating programs written in the C programming language

1. Introduction
Programs for electronic computers are prepared in a symbolic, human-understandable programming language
language. The C programming language will be used for this purpose in the Introduction to Programming course.
A program written in symbolic language and written in a file with the extension .c must be converted to
commands understood by the processor, i.e. executable machine code (on the Windows operating system
file with the extension .exe, on Unix/Linux operating systems the form of the extension is not prescribed).
The conversion process is carried out in two steps (the concept of preprocessing and assembly code creation will
can be omitted here because it is indivisible as part of the translation):
a) Translation into object code is performed by a program called a compiler.
The compiler translates file by file symbolic code and creates object files
code (usually with the extension .o), which cannot yet be executed because they do not yet exist in it
links to functions and variables from other object code and program files
libraries in which standard functions (input/output, mathematical
functions, etc.).
b) Linking into executable code is done by a program called a linker. That program
merges all necessary object code files with pre-prepared program files
libraries and creates executable code that can be run directly from the operating system.
To prepare the source code of the program (writing the program) you can use any one already on the computer
installed text editor that will not embed additional hidden formatting tags into the file
as Word does, for example. An example of such a program is the basic Notepad editor or something improved
Notepad++. The compiler and linker are often not part of the operating system and need to be installed. On
in the Introduction to Programming course, for this purpose, the MinGW package will be installed in the 32-bit version
(https://en.wikipedia.org/wiki/MinGW).


2. Installation of the MinGW package
From the pages http://sourceforge.net/projects/mingw/files/latest/download?source=files it will automatically
the installer, mingw-get-setup.exe, is downloaded.
The downloaded program must be launched, on the first form press the Install button, on the next one
Continue. The download of the so-called MinGW Installation Manager, after which you need to squeeze more
once Continue which will start the MinGW Installation Manager.
In the left field it is necessary to select Basic Setup and then in the right field mark (Mark for
Installation) item mingw32-base.
After that, select Installation -> Apply Changes in the menu and press the Apply button in the newly opened window.

After the installation, it is necessary to adjust the Path system variable by adding the path to
MinGW package bin folders. This system variable contains a list of folders in which the operating system searches
executable programs that the user tries to run by specifying their name.
If MinGW is installed with default settings, the path of the bin folder of the MinGW package
it will be C:\MinGW\bin.
This can be done in several ways, but the simplest is in the command window.

Opening a command window (command prompt)
The command window is started by starting the basic Windows menu (Start menu, ), then
type and select the Run action, then in the next window type cmd and press OK, or so that after opening the basic menu, type command and the offered action is started: click on the offered program "Command Prompt".
It is useful to immediately embed the call to the command window in the main menu by right-clicking
clicks the mouse on the offered action and selects Pin to Start from the pop-up menu.
The command window enables direct assignment of operating system commands, which in general
case they look like this:
program argument1 argument2 … argumentn
program is the name of the program (or internal operating system commands) to be executed. If
program is not an internal command of the operating system (like the DIR command that prints the contents
current folder), must be located either in the current folder or in one of the folders listed in the variable
Path which is set as described in the next chapter. The program can be called without
arguments like dir, and the arguments are the names of files that the program will operate on or options that
modify the way the program is executed. Options usually start with the characters /, - or --. In the next one
for example, copying the file t1.txt to t2.txt with the command copy t1.txt t2.txt requires confirmation if
t2.txt already exists, but if the /y option is added to the call, then confirmation will not be required (copy /y t1.txt
t2.txt).
It should be noted that some operating systems are case-sensitive in the names of programs and options
or file, while others do not. The Windows operating system does not distinguish between upper and lower case letters (case
insensitive), while Unix and Linux operating systems do so (case sensitive).

Setting the Path system variable in the command window
The Path system variable is most easily set in the command window with the command
setx Path "%Path%;C:\MinGW\Bin"
The command setx written in this way sets the new value of the Path variable so that the old value at
add the text ;C:\MinGW\Bin at the end
Unfortunately, the setx command has a built-in variable length limit of 1024 characters, so before
calls should be checked that the existing content is not too long, which can be checked with the echo command:
echo %Path%
If a message appears when setting a variable
WARNING: The data being saved is truncated to 1024 characters.
means that the built-in limit of the setx command has been exceeded, so the Path variable will need to be set
through the graphical interface and check the content.

Setting the Path system variable through the graphical interface
The Path system variable can be adjusted in the Control Panel:
Control Panel -> System and Security -> System
You need to run the Advanced system settings link on the left
In the newly opened window, select the Advanced tab and then press the Environment button
Variables…
After that, it is necessary to select the Path variable in the System variables list and click on the Edit button.
A window will open with all the set folders in which the operating system searches for executable programs,
on which the New key should be pressed.
In the newly created empty field at the bottom of the list, enter the path to the folder where the package is installed
MinGW to which you need to add the bin subfolder and press OK.
In older versions of Windows, on Edit, a window will open in which the Variable value field, at the end
of the existing text should be added
; C:\MinGW\bin\
Pay attention to the sign; at the beginning of the text that is added to the Path variable. They separate with this sign
paths contained in the Path variable. The specified text is added to the end of the existing content of the variable
Path, taking care not to delete the existing contents of the variable.
If MinGW is installed in another folder (instead of C:\MinGW) then in the text it is supplemented
the Path variable, in both described ways, should be replaced by C:\MinGW with the path to that folder.

Alternative installation method
Students who have problems installing the latest version of the MinGW package on their Windows
computer can try this alternative method:
1. On the computer, create a folder where the MinGW files will be placed (eg C:\MinGW\)
2. Download the MinGW.zip archive from the file repository and unpack it into the folder created above
3. Set the Path system variable according to the instructions above


3. Writing a program with a simple editor, translating and executing the program
The entire process of writing and translating will be illustrated in the command prompt where
first you need to create and position yourself in the folder where the program file will be stored, e.g.
mkdir C:\UPRO
cd C:\UPRO
and start editing the program there with a text editor, e.g.
notepad program.c
The following code should be entered in the file thus created:
#include <stdio.h>
int main(void) {
  printf("Introduction to programming");
  return 0;
}
and save the changes via the File/Save menu or with the standard keyboard shortcut Ctrl-S (it is pressed
the Ctrl key and then, without releasing it, the S key).
After that, it should be checked whether elementary translation with the command succeeds
gcc program.c -o program.exe
This simplest gcc compiler call combines the compiler and linker functions. It is being translated
file program.c and, because of the -o (output) option, creates an executable file named program.exe which
can then execute with the command
program.exe
or
program

If an error occurred when calling the translator or starting the program, possible solutions should be found
look for it in the next chapter.
In essence, this kind of interpreter call internally does the same thing as the following sequence:
gcc -c program.c
gcc program.o -o program.exe
where the first call, due to the -c (compile) argument or option, is just a translation into object code
program.o, which in this case remains written in the current folder (with an elementary call, that object code is automatically deleted), and the second call connects the object code with the program
libraries and creating an executable program.exe.
The translator options that should be used in the Introduction to Programming course are also:
-std=c11 – parameter that ensures translation according to the ISO/IEC 9899:2011 standard
(there is also a newer ISO/IEC 9899:2018 standard, the -c++17 option, but gcc currently applies it
only in C++.
-pedantic-errors – a parameter that requires detailed printing of errors in the program
-Wall – parameter that requires a detailed warning printout
The command that compiles the program with the specified options included looks like this:
gcc -std=c11 -pedantic-errors -Wall program.c -o program.exe

Configuration for MacOS
Install gcc using Homebrew: https://brew.sh/
1. Install Homebrew by executing the command in the terminal:
/bin/bash -c "$(curl -fsSL
https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
2. Install gcc:
brew install gcc
3. Check if elementary translation succeeds with the command:
gcc -o <output-file-name> <input-file-name>
for example
gcc -o output_program program.c
4. Export the executable file:
./output_program


4. Possible problems when compiling or executing the program
Problem with Path variable
If you get the following error when starting gcc:
'gcc' is not recognized as an internal or external command, operable program or
batch file.
then probably the Path variable was not set or refreshed correctly. In that case, it should be in order
take the following steps. After each step, you can check whether the problem is solved.
1. Check if the Path variable is set correctly by typing the command
echo %Path%
If the error is in the path, fix it as described in the previous chapter.
2. Close all command windows and open the command window again.
3. In the Task manager, restart explorer.exe
4. Restart the computer

Antivirus software problem:
If the following error appears when starting the translated program (executable .exe file):
The system cannot execute the specified program
it is possible that the built-in security mechanism (Windows Defender) or some other antivirus software
automatically blocks the launch of an unknown executable file. It is then necessary to disable blocking
programs that are launched from the folder where the .exe is created.
For Windows Defender, this can be done as follows:
Select Control Panel -> Windows Defender and click on Settings in the upper right corner.
In the open window, under Exclusions, select Add an exclusion.
In the next window that appears, select Exclude a folder and then select the folder in which it is located
located program code (eg C:\UPRO).
After that, the compilation of the program should be restarted using the gcc command and run
executable program (.exe).

5. Writing and translating programs in an integrated development environment
Knowledge of basic program editing with notepad or a similar text editor, translation
program from the command line and running the program from the command line is mandatory and will check
in laboratory exercises.
Integrated Development Environments (IDE) are used for convenience
writing, translating and testing programs. The subject Introduction to Programming will be taught in
development environment Visual Studio Code because it is an open source program, it works on more
platforms (Windows, Linux, Mac), the installation package is, compared to other similar environments,
relatively small, installation is fast, and can be used for programming in any software
language, provided that a suitable compiler is installed on the computer, such as the MinGW package whose
installation and use described in previous chapters. It is understood below that the package
MinGW installed according to the instructions from the previous chapters.

Environment installation
Visual Studio Code (VSC) is downloaded from the link
https://code.visualstudio.com/download
After selecting the platform, downloading and running the installer and successfully completed
installation, VSC is ready to run.
The VSC working environment considers one folder in the file system as a whole (project). That's why
the first action to be taken is to open the folder in which they are located or in which the programs will be located
files, for example the folder where we tested the work of the gcc compiler.
The VSC toolbar consists of the following icons:
Explorer (work with files in the currently open folder
Search (search for content in the currently open folder and subfolders
Source control (working with the GIT version control system)
Debug (starting the program and eliminating malfunctions in the program)
Extensions (installing VSC extensions)
First of all, it is necessary to install an extension that enables work on programs in the programming language
C or C++. In the extension search field, type C/C++ and then select Microsoft
expansion.
After downloading, it is necessary to restart VSC by pressing the Reload button.

Environment configuration for simple programs
With this, unfortunately, VSC is not yet configured to compile C programs. Configuration is possible
to do through the menus, but the simplest is to create a subfolder .vscode (notice that the name begins
point) and in it two files written in Javascript object notation (Java Script Object Notation, JSON):
tasks.json describes the tasks to be performed as part of the program translation
launch.json describes how to launch the executable.
The files are created by selecting the folder in which the files should be created
corresponding icon and type the name of the new file.
In the window on the right, the following code should be copied into the tasks.json file:
{
    "version": "2.0.0",
    "tasks": [{
  "label": "Build with gcc",
  "type": "shell",
  "command": "gcc",
  "args": ["-g", "-std=c11", "-pedantic-errors",
  "-Wall", "-o", "program.exe", "${file}"
  ]
     }]
}
Essentially, we create a task that will be called Build with gcc ("label"), which is an operating command
system ("type":"Shell"), and the specific command to be executed is gcc ("Command"). "args" is a list
arguments in the call of the external program. ${file} is the name of the currently open program file,
so if the code written in program.c is currently open in the window, the previous description will result
with the following operating system command:
gcc -g -std=c11 -pedantic-errors -Wall -o program.exe program.c
i.e. by the already known call of the compiler, which will create, in addition to (mostly) known options from program.c
program.exe
The novelty here is only the -g option, which adds interaction with the debugger to the executable code
(debugger).
It should be noted that this configuration is only good for programs that consist of one
executable code files, but that's why it allows an unlimited number of them to be in the same folder
simple programs.
In the same way, the file launch.json should be created and copied into it
{
     "version": "0.2.0",
     "configurations": [
         {
  "name": "C Launch",
      "preLaunchTask": "Build with gcc",
             "type": "cppdbg",
  "request": "launch",
             "program": "${workspaceRoot}/program.exe",
  "args": [],
             "stopAtEntry": false,
             "cwd": "${workspaceRoot}",
             "environment": [],
             "externalConsole": true,
             "miDebuggerPath": "gdb.exe",
             "linux": {
  "MIMode": "gdb"
  },
  "osx": {
  "MIMode": "lldb"
  },
  "windows": {
  "MIMode": "gdb"
  }
  }
      ]
}
In short, we specified the name of the job that must be started before our program runs
("preLaunchTask"), the path to our program ("program") and the path to the removal program
errors ( "miDebuggerPath" ). The task name ("preLaunchTask" must match the text in the "label" option in the
tasks.json. It should be noted that in this case sa is the character that separates the folder levels in the slash path
(slash, /) and not backslash (\).
In the above configuration ("miDebuggerPath") it is understood that the folder in which it is installed
debugger gdb.exe is located in the PATH system variable. If this is not the case, it is necessary to enter the correct one
the absolute path to the gdb.exe file.
Now we only need to open our file with the original program (because it is specified in the configuration
to compile the program that is currently open in the editor) select Debug and start the program by pressing Start debugger or by simply pressing the F5 key on the keyboard.
Consequently, the program will be translated in the way described in the prelaunch task from tasks.json and then,
if the translation was successful, launch the program as described in launch.json.

If the program has been changed in any way in the meantime, the x next to the program name will change to a circle and the changes will need to be saved with File/Save or Ctrl-S before translation.
This action will print the text Introduction to Programming in a new window that will close immediately afterwards.
To prevent the window from closing immediately, a breakpoint should be set on the last line of the program,
by pressing the mouse button at the very beginning of the line containing the return command.
If a new folder is created for another program or programs, you simply need to copy the whole folder into it
folder .vscode with which all preparatory actions have been completed.

Debugger Basics
Program behavior is easy to monitor using a debugger. For demonstration
for the operation of such a program, we will replace the commands in the program.c s
#include<stdio.h>
int main(void){
  int i;
  i = 0;
  i = i + 1;
  printf("Value of i: %d\n", i);
  return 0;
}
and follow the execution of that program step by step.
In short, here we define one variable, set its initial value, increase it by 1 and
at the end, we print its final value in the window with the accompanying text.
In the program, it is necessary to first set a breakpoint on the command in front of which it is needed
stop the execution of the program by pressing the left mouse button at the very beginning of the corresponding line.
After compiling, the program starts and stops at a breakpoint.
By hovering the mouse over the name of the variable, you can get an insight into its value.
The apparently random number should not surprise us, because the definition of the variable only provides space for it in the memory, but
not the default value.
The debugger's toolbar responds to hovering the mouse badge with a popup in the
where it is possible to see the meaning of each icon and the shortcut by which the corresponding action can be taken
run and contains the commands in order (in parentheses are the original names of the actions and the corresponding shortcuts):
Continue execution to the end or the next breakpoint (Continue, F5)
Executing the next command without entering the function code (Step over, F10)
Executing the next command by entering the function code (Step into, F11)
Exiting the current function (Step out, Shift-F11)
Restarting the program with recompilation (Restart, Ctrl-Shift-F5)
Stopping the program (Stop, Shift-F5)
If the next command is executed with the Step Over action, the program stops after executing the command a
Hovering the mouse badge over the variable name indicates that the content has changed.
The state of several variables in the environment of the command on which the program is stopped can also be monitored in the window
Locals. In larger programs, some variable that is not in the Locals window may disappear
environment of the current command. In such cases, a variable or an expression whose value is desired constantly
watch can be added to the Watch window.

Environment configuration for more complex programs
More complex programs regularly consist of multiple source code files (modules), because navigating the
large source files quite difficult. If the program consists of files (modules), for example p1.c,
p2.c and p3.c, should be in tasks.json, in line
"args": ["-g", "-std=c11", "-pedantic-errors",
"-Wall", "-o", "program.exe", "${file}"]
replace "${file}" with the list of modules that make up the program:
"args": ["-g", "-std=c11", "-pedantic-errors",
"-Wall", "-o", "program.exe", "p1.c", "p2.c", "p3.c"]
The disadvantage of this approach is that it is performed every time the program is started
translation of all listed modules, regardless of whether they have been modified in the meantime.

Environment configuration for complex programs using make
Unnecessary translation can be avoided by using the make program in which dependencies are defined
executable program about object code files and object code files about source files
the code. If the program notices that, for example, a source code file is newer than an object code file that depends on it, it will compile that file. Files whose source code is older than the one it belongs to
object code will not be compiled.
The make program is located in C: \MinGW\bin (or in the appropriate folder if MinGW is not installed on
standard mode) under the non-standard name mingw32-make.exe, so it's useful to copy it to the
make.exe with the copy command
copy C:\MinGW\bin\mingw32-make.exe C:\MinGW\bin\make.exe
Dependencies are described by rules in the Makefile file, which should be located in the same folder as
source code files.
The Makefile that describes translating program.c to program.exe looks like this
program.exe: program.o
gcc -o program.exe program.o
program.o: program.c
gcc -c -g -std=c11 -pedantic-errors -Wall program.c
Here we described that program.exe (executable code) depends on program.o (object code) and that program.o depends
o program.c. If something changes in program.c, that file will become newer than program.o and be done
will, thanks to the -c (compile) option, be translated into object code, which will make the object code more recent
from the executive which will cause linking.
It is important to know that the indentation of the command that is performed for the corresponding rule is mandatory, i
it must be marked with a tab (Tab) sign and a line describing the dependency of the executable code on the object code
must be written first.
In practice, there will be a dependency of the object code files and on the so-called header files which
are included in the translation with the preprocessor command #include.
If, for example, the program consists of two modules, p1.c and p2.c, the first of which with the command #include
includes h1.h and h2.h and the other includes h3.h, it will be described as follows:
program.exe: p1.o p2.o
gcc -o program.exe program.o
p1.o: p1.c h1.h h2.h
gcc -c -g -std=c11 -pedantic-errors -Wall p1.c
p2.o: p2.c h3.h
gcc -c -g -std=c11 -pedantic-errors -Wall p2.c
This approach requires a make call to be described in tasks.json. It is possible simply
replace the gcc program call with the make program call while deleting the argument list (make no
requires arguments if dependencies are described in an assumed Makefile, otherwise
arguments when calling should be -f make_file_name). Alternatively, it can be added to tasks.json
new task as follows:
{
  "version": "2.0.0",
  "tasks": [{
  "label": "Build with gcc",
  "type": "shell",
  "command": "gcc",
  "args": ["-g", "-std=c11", "-pedantic-errors",
  "-Wall", "-o", "program.exe", "${file}"
  ]
       },
       {
  "label": "Build with make",
"type": "shell",
  "command": "make"
        }
     ]
}


In any case, make sure that the "preLaunchTask" option in launch.json references the appropriate one
task, in this example like this:
"preLaunchTask": "Build with make"

Optional: Universal Makefile
In the previous examples, only the basic functionality of the make program was shown. With familiarity
more advanced functionalities, the details of which we will not go into here, it is possible to write a Makefile which
can be used to translate any complex program, without explicitly specifying individual ones
components and their dependencies. Very superficially explained, it states that all files are s
with the extension .c source files for the program, and all files with the extension .o object code and are created from
source code of the same base name. The compiler name and options are stored in the CC and CFLAGS variables.
CC = gcc
CFLAGS=-c -g -std=c11 -pedantic-errors -Wall
SRCS=$(wildcard *.c)
INCLUDES=$(wildcard *.h)
OBJS=$(SRCS:.c=.o)

main.exe: $(OBJS)
$(CC) -o $@ $(OBJS)

$(OBJS) : %.o: %.c $(INCLUDES)
$(CC) $(CFLAGS) -c $<
clean:
del *.o *.exe
Finally, a rule has been added here that enables the deletion of all object and executable code files.
This, like any other individual rule, can be executed by calling the make program with the specification
rule names, in this example make clean. The first subsequent call to make will cause
translation of all program modules.


6. Code formatting
Properly formatted code is a prerequisite for program readability. The C compiler will compile without problems
the following program:
#include <stdio.h>
int main(void) { if
(1) { printf ("1"); } else {
printf ("2"); }}
but it is almost impossible for a person to manage in such a program. Let's compare the previous program with
equivalent, but properly formatted:
#include <stdio.h>

int main(void) {
  if (1) {
  printf("1");
  } else {
  printf("2");
  }
}

The VSC extension for C/C++ will format code with Alt-Shift-F.
The functionality of automatically formatting the code when saving changes is built into this
extension, but it is disabled in the default settings. Automatic setting
code formatting when saving is included in File/Preferences/Settings.
This, as well as all VSC settings, can be set at the user level (User settings, will be valid in any
which project/folder) or at the folder level (Workspace settings, will only be valid in the current folder).
It is therefore necessary to first mark the level with the mouse on the right side of the screen (in the following example, User
settings so that the setting is also valid in other projects). Then you need to look for the setting
by typing the name of the setting in the search field. Some settings can be edited in
with the appropriate fields, some, for now (the environment is in constant development), by editing the JSON object.
The specific setting is edited by editing the JSON object, where next to the line editor.formatOnSave, the pencil icon is pressed with the mouse and true is selected.
The default formatting style is somewhat wasteful. While saving the above
of the program code will be automatically formatted as follows:
#include <stdio.h>
int main(void) {
if (1)
  {
printf("1");
  }
otherwise
  {
printf("2");
  }
}

This can be changed by adding to the folder where the source code to be formatted is located
file with the name .clang-format and enter the IndentWidth setting, which we use to determine the depth
indents of each level of program commands. Indentation of 3 letter spaces is recommended
IndentWidth: 3
The space after the colon is mandatory.
For correct formatting, it is also necessary to change the tab width in the VSC settings.
In the search field in the window that opens on the right, type tab and the Tab size field
set to 3 (default is 4).
With the existence of this file, the program will be formatted in an optimal way after saving
of the used number of program lines and its readability, as was already shown:
#include <stdio.h>
int main(void) {
  if (1) {
  printf("1");
  } else {
  printf("2");
  }
}
In this file, it is possible to enter the BasedOnStyle setting, which will determine the formatting style.
Allowed values are LLVM (this is the default value), Google, Chromium, Mozilla and
WebKit.
We leave it up to the readers to experiment with these settings.

7. Configuration files for VSC
The configuration.zip file contains all the configuration files described in this text. Whole
the content of this compressed file should be copied to the folder where the original programs will be, for example:
C:\UPRO, so that after copying the folders contain ".vscode", ".clang-format", "Makefile" files.
After that the folder can be opened in VSC and start editing and translating the program.
Various configurations are embedded in these configuration files, so for easy
compiling the currently open program should select the C Launch configuration.


Instructions for performing laboratory exercises and checking knowledge on the computer through the Edgar system

1 System Edgar
The Edgar system is used for automatic assessment of tests of theoretical and practical knowledge from the subject Introduction
into programming. In this course, you will encounter tasks of the programming type, where is for default
problem, it is necessary to write a programming solution in the programming language C.
Tests contain programming tasks that are solved and tested in the Notepad(++) or development editor
environment to VSC, and the final solution is transferred (copy-paste) to the Edgar system.
You can access the Edgar system at: https://edgar.fer.hr/
Note: Appearance and arrangement of graphical user interface elements on the current version of the system
Edgar may differ partially from the appearance of the user interface shown on
images below this document. The interface of the Edgar system is in English, but it is
content (questions and answers) in Croatian. In case of any ambiguities and/or difficulties
when using the system, contact the assistant on duty.

1.1 Login to the system
To log into the system, use the username and password from the AAI-Edu system. You can use this method of registration
access by clicking "login here using AAI".
Then it is necessary to enter the AAI username and password in the login fields and click "LOG IN".
Note: The username from the AAI-Edu system is of the form <your FERweb username>@fer.hr. (e.g. for
Ivana Kolara with JMBAG 0036497556 username is: ik49755@fer.hr).
If you do not have an AAI-Edu user account, please contact the Faculty Information Center
support (CIP).

1.2 Using Edgar for Introduction to Programming
In order to get access to the tasks and tests in the course Introduction to programming for current in Edgar
academic year, it is necessary to select the correct subject and academic year from the drop-down menus
on the right side of the main menu.


2 Checks
Note: In laboratory exercises, it is allowed to use official reminders:
1. Official reminder for the C programming language
2. Official reminder for the gdb program
You can have them with you in paper form, but they will be in laboratory exercises and exams
available in checks through this system is the last question in the check.
Knowledge checks are only available at a preset time interval.
Knowledge checks on laboratory exercises are accessed using a password. You will check passwords
find out from the assistant on duty just before starting to write each check.
After entering the appropriate password, the check is started with the "Start exam" option.
There are also so-called public examinations (Public exams) that can be started without knowing the password. Shown
are on the front page under Public exams.
To practice working with the system at home, a demo check has been defined that can be run
an unlimited number of times in any of the above ways. The verification password is DemoUPRO. points
demos won by checking are not included in the total points of the course.
The links at the top of the screen are used to navigate between the verification tasks. With the serial number of each
task, information about the student's current answer is displayed in parentheses:
1. minus sign next to the serial number of questions that have not yet been answered
2nd letter (a, b, c,...) next to the ordinal number of the question to be answered by choosing one of the offered ones
answers
3rd sign / next to the serial number of the question for which a program solution is expected, and the solution is the student
wrote.
With each task, information is shown on the points that the student earns for being correct (Correct),
unanswered and incorrect answer.
In the upper right corner there is a clock that counts down the time until the end of writing the test, a picture of the examinee and
the "Submit" button, which submits the entire test (not individual tasks!) for final evaluation.
The student is obliged to submit the test for evaluation by the end of the time, but he will also do so within a reasonable time
time after the expiry of the check, it will be possible to submit it for evaluation. This timeout will, however,
be recorded in the system, so the check can be canceled later.
In the upper left corner (next to the name of the check) there is a button to select the form of orientation of the field for
answer and question frame.

2.1 Checks with program tasks
Important: the programming task must first be solved on the computer. This means that before teaching solutions to the system
Edgar, the program needs to be written (e.g. with Notepad/++ editor or in VSC), translated (by calling
compiler gcc), remove all errors and warnings, and thoroughly test by execution
program with different test data. Only when you consider your solution correct, program code
which you have written, you will use copy-paste to transfer it to the Edgar system.
For tasks that require writing program code, in the Edgar system it is located below the text of the task
the field in which the solution (program code) should be transferred.
Program code uploaded to the Edgar system can be run in the following ways:
- by selecting the "Run" option
- while the field with the program code is in focus (the mouse pointer is in the field), by combination
"Ctrl + Enter" keys.
If errors or warnings occur while compiling the source code, it is forwarded
error/warning reported by the gcc compiler, as illustrated by the example below where
there is a syntax error in the program and one data type warning.
If the program compiles successfully, the program will start with several presets
cases for testing. If the output from the program does not correspond to the expected in any case, from the total number
a certain percentage, given in advance for that case, is deducted from the points allocated for the task. That
percentage can be
- 100% if it is a typical test case, for example if a program that determines whether a given number is
in the requested interval does not work well for numbers inside or outside the interval, or
- less than 100% if the test case examines the behavior of the program at the very limits of the interval.
The total percentage of points deducted for a task cannot exceed 100%.
The process of writing tasks in the Edgar system will be illustrated on the example of one of the tasks from test s
with the password DemoUPRO which reads:
Write a program that prints the message specified in the examples that follow, loading integers
a and b, it prints them separated by one space, and below that in a new line it also prints their sum.
Example 1:
Hello·World!·A·now·enter·a·i·b·>·15·20↵
15·20↵

35

Example 2:
Hello·World!·A·now·enter·a·i·b·>·-5·20↵
-5·20↵
15

The sign `↵` in the examples indicates that '\n' should be printed in that place (transition to a new line, Line feed) or
press the Enter or Return key, and the sign `·` indicates that a space should be printed in that place.
Try copying and pasting the following program into the solution field:
#include <stdio.h>
int main(void) {
int a, b;
  printf("Hello World! Now enter a and b > ");
scanf("%d %d", &a, &b);
  printf("%d %d", a, b);
  return 0;
}
This program prints the message `Hello·World!·A·now·enter·a·i·b·>·`, loads two
whole numbers and then prints them separated by two spaces. In addition, it does not print the sum.
If exactly such a program is executed, Edgar will report the result for each of the four provided tests
faulty. Each row of the table corresponds to one test case. The mark "Incorrect" indicates that for this case printing
of the program was not as expected. The percentage next to the test case indicates the percentage
from the estimated number of points for that task, he loses if the solution does not meet that test. In concrete
case, for any of the tests in the example above, all points for that task are lost. So, in order to
achieved 100% points on a task, the solution must be correct for all tests prepared for
that task.
Now try replacing the print command with the following command:
printf("%d %d %d", a, b, a + b);
The result of program execution will be
Hello·World!·A·now·enter·a·i·b·>·15·20↵
15·20·35


The program prints the correct values of the loaded variables and correctly calculates and prints their sum, but
during testing, this solution is also evaluated as incorrect in all cases, because the transition is missing
to a new line. One space or transition to a new line of surplus/deficiency is enough, so that's almost correct
the solution fails the test.
Only if the print command is corrected to
printf("%d %d\n%d", a, b, a + b);
the program will return the correct result in all test cases.
In case of an unforeseen circumstance (e.g. power outage), Edgar enables the current storage
contents of the solution field:
 Explicit - the content of the field can be explicitly saved by selecting the "Save" option at the top
right corner (under the "Run" option).
 Implicit - Edgar automatically saves the content of the field every time it is started with the "Run" option.
Therefore, "Save" should only be used if you have written the program code and not run it.
If an interruption of writing a check occurs, the check can be accessed again in the same way as at
the first time the check is started - by entering the check password. The system shows everything on the front page
tests that you have started but not submitted (You have unsubmitted private exams), as well as the deadline
until which check writing is enabled (Available until). Enter the appropriate password to continue
work on interrupted check.

2.2 Completion of writing and submitting the test for evaluation
After writing all tasks, the test must be submitted for final evaluation by selection
"Submit" option in the upper right corner of the window. The submission is confirmed once again by selecting "Yes,
submit test!", but it can also be canceled by selecting "No, continue writing". Also, on the screen will be
your solutions to certain tasks are shown, which is good to check again.
Then it is necessary to wait for the completion of the evaluation.
After the evaluation, the summary results of the check will be displayed. Within 10 minutes of submission, the system
enables an overview of the verification solutions for individual tasks. Access to the review by individual tasks
by selecting the "Review" option.
After the expiration of the 10-minute period from the submission of the check, the review by questions will be disabled, but
the summary status of the check points will still be displayed, but without the "Review" option.
  Settings (so-called screens) for display in Edgar can be adjusted
using the "Code theme" option.
The overview of the summary results of all checks carried out so far can be accessed at any time
by selecting the "My previous exams" option.

3 Support system (ticketing system)
In order to facilitate communication between students and teaching staff related to tests in Edgar (e.g.
preparation for labs, mid-term exam, final exam and the like), Edgar offers a support system called Ticketing system. IN
in case of doubt, doubt about the accuracy of the solution or something else, the student can ask a related question
with a specific task.
The use of the system while writing a check is described below:
1. Click on the icon in the upper right part of the page with the question
2. Enter the description of the problem in the window that appears and confirm it by clicking Yes, raise ticket.
The student continues with the check, he does not have to wait until he receives an answer.
The icon turns red and an hourglass icon appears next to it.
While waiting for an answer, the student is not able to send additional messages related to the same task (incl
some other task, of course, can).
3. The teaching staff will check what it is about and answer the student as soon as possible.
After answering the question, a notification appears on the student's screen. A student in that
he can be on any question at the moment because he didn't have to wait for the answer to the question he is on
sent a message (posted an inquiry).
4. The student can then return to the question on which he sent the message and check the answer.
The answer can be viewed by clicking on the green cloud icon.
Note: Only after the teaching staff answers the question related to the assignment, the student
if necessary, he can ask the next question with the same task - the icon turns green again.

3.1 Review of own tickets
The student can view the messages sent in connection with the examination questions using the My tickets menu options.
This option is useful when the question asked by the student cannot be answered quickly (in time
duration of the check) because it provides the possibility of subsequent review of the answers of the teaching staff. For example,
there is a (fatal) mistake on the part of the teaching staff, and because of that, it is subsequent to all students
answer recognized as correct.
Note: It is not possible to ask questions on the DEMO Upro test.


Introduction to programming
A guide for students

1. Introduction
The subject Introduction to programming is a compulsory subject in the study program of Electrical Engineering and
information technology and computer science.
The goal of the course is to learn basic programming concepts and the ability to create less complex ones
programs in the C programming language.
Web-address of the course:
http://www.fer.hr/predmet/uup_a
All information, lecture materials, practice tasks, instructions, official are published here
reminders, etc. Also, in case of need, students will receive notification by e-mail, therefore
you should check your email inbox @fer.hr.


2. Forms of teaching
1. Lectures
Lectures take place in two cycles. After the first cycle, intermediate exams are held, and after the second
cycle final exams.
- lectures in the 1st cycle, October 2 - November 15, 2023.
- lectures in the 2nd cycle, December 4, 2023 - January 24, 2024.
During the lectures, the planned material is presented with the help of Powerpoint slides,
solve tasks, discuss, conduct ad hoc surveys and knowledge tests for which no points are awarded,
but which can be used by students to determine knowledge and self-assessment
- the displays that will be presented at the lectures are published on the course page
at least a few days before the lecture
- the content of the displays, since they are published in advance, should not be copied, but it is advised to
take your own notes during lectures
- actively participate in lectures: solve tasks assigned during lectures, ask questions
teacher for additional clarifications
- just following lectures and/or reading presentations will certainly not be enough to pass
exam, so pay close attention to the content of the Independent Work chapter


2. Independent work
The course is taught with a load of 7 ECTS points, which means that the total engagement of the student,
required for successful mastering of the material, estimated at 7 x 30 = 210 hours. From that
- attendance at lectures requires 50 hours
- attending laboratory exercises and knowledge tests requires approximately 20 hours
- the remaining time, i.e. 140 hours, is intended for independent work
It should be noted that 140 hours of independent work, when distributed over all weeks in which classes are held,
means approximately 10 hours of work per week, in addition to attending lectures and laboratory exercises. Cause of
layered approach in processing the material, it is very important to work continuously, every week, following
lecture by lecture. Campaign work (e.g. I won't do anything for three weeks and then suddenly
to do thirty hours) will almost certainly result in very poor results in this subject.
Independent work includes:
- Learning
   o presentations from lectures
   o own lecture notes
   o reading other literature (see chapter Literature)
   o Internet
- Solving tasks
  by solving a large number of tasks on your own computer, you acquire the necessary skills
   skills (designing a simple algorithm, writing code, translating, observing
   of errors, testing) which are checked in laboratory exercises and written tests
   knowledge tests (interim exam, final exam, exam period)

  o solve tasks from lectures, test examples of programs and program clips s
    lectures, independently modify these examples, observe the effects of the modifications
  o solve tasks for exercises in addition to lectures
      Along with each lecture, an average of ten exercises are published which
     are mostly related to the topics covered in those lectures.
     So, for example, along with the first lecture, the 1st exercise document was published along with the lectures,
     with another lecture 2. exercises with lectures, etc.
      Exercises with lectures should definitely be solved before the next lectures. Each
     of the tasks should be carefully read, written and tested on the computer
     program comparing the results obtained by executing the program with
     to the requirements from the task and/or execution example listed with the task
     IMPORTANT: the solution to the task is published with each task. However, attached
    do not read the solution before solving the task yourself
    completeness, including testing. The attached solutions should only be used for
    subsequent comparison with your own solution. Making the biggest possible mistake
    students who will "solve" the exercise tasks in addition to the lectures on the following
    method: read the task, look at the solution and conclude that it is easy, because
    they understand the solution. Between understanding a program that someone else
    wrote and the ability to design an algorithm and write his own program
    a very long way.
     it is advised to save your own solutions to exercises for lectures.
    You may want to look at how you did after a while
    individual task. For example create one folder for each exercise (folder,
    directory) and save files with the source code of your own solutions in it.

3. Laboratory exercises with knowledge checks
Students perform exercises on the computer in the laboratory, in precisely prescribed times
-four exercises in the 1st cycle and four in the 2nd cycle
- the duration of one laboratory exercise is approximately 110 minutes
- the student must complete the laboratory exercises exactly in the allotted time
- there is no compensation for laboratory exercises
- the laboratory exercise consists of two parts
- solving tasks in which the correct one must be chosen from among several offered answers
("rounding problems"). A correct answer brings positive points, an incorrect answer
negative points. An unanswered question does not earn negative points.
- creation of one or more programs (algorithm design, coding, testing). In these
assignments are not awarded for an incorrect answer (defective program) or absence of an answer
negative points
Each student works independently on the faculty computer, but under the supervision of the teachers on duty.
The student has at his disposal the same tools that he uses to solve tasks on his own computer
- Notepad and Notepad++ editors, gcc compiler used via character interface
(command line) of the operating system
- VSCode development environment
IMPORTANT: regardless of which of the aforementioned options the student chooses, knowledge
elementary program editing with the Notepad/Notepad++ editor, as well as translation and launch
program from the command line is mandatory!
Schedule by dates, number of questions and program tasks per individual exercise, and the largest number
the points that can be obtained for each exercise will be on time, at least one week before the exercises,
published on the course website.


4. Consultations
Students who regularly attend lectures have the option of consulting in
unlimited number and duration. It is recommended to use the consultation whenever necessary.
   - the lecturer will be more than happy to explain the material to you during the consultation, but will not explain it again
teach
   - consultation should be requested as soon as ambiguities arise that you are unable to resolve on your own or with
the help of colleagues. Do not delay the consultation until just before the midterm or
final exam - at that point it will most likely be too late
Consultations are possible for individual students or groups of several students
   - consultation with the lecturer in your group
     o each lecturer will present the method of agreement on consultations in his group
     o individual short consultations can also be held during lecture breaks or
      immediately after the lecture
     o also feel free to use e-mail to ask questions to lecturers
   - consultations with assistants
     o organizational issues, eg problems with the schedule of laboratory exercises and the like
     o by email: UPROlabosi@ferhr.onmicrosoft.com

5. Knowledge tests
During continuous monitoring of classes, two written tests of knowledge are performed: mid-term exam i
final exam
- exams are held according to a pre-defined schedule published on FER
websites
- part of the tasks can be in the form of questions, part of the tasks can be based on choosing the correct one
answers, but most of the tasks are related to solving the given problem in programming
to the C language
- tasks are solved on the computer, under the supervision of assistants, in the premises of FER
- solutions are scored by the Edgar system, but these points do not have to be final; final points
assigned by teachers after reviewing student solutions
- there is no compensation for mid-term and final exams in case of absence
Students who fail to pass the course during the continuous monitoring of classes, can take the exam dates
- exams are held according to a pre-defined schedule published on FER
websites
- on exam dates, the exams are similar to the midterm and final exam, but as a rule, more comprehensive


3. Evaluation elements and grades
1. Conditions for obtaining a passing grade
During continuous monitoring of classes
The total number of points acquired during continuous monitoring of classes is obtained by adding up the points
obtained in laboratory exercises and points obtained in the midterm and final exam
- total number of points = number of points lab. see + number of points midterm + number of points final exam
Conditions for obtaining a passing grade based on continuous monitoring of classes:
- achieved a threshold of at least 16 (out of 40 possible) points on the final exam i
- total number of points >= 50
Laboratory exercises carry a maximum of 30 points and have no point threshold. The Meduispit carries a maximum of 30 points and has no point threshold.
The final exam carries a maximum of 40 points and has a point threshold of 16 points.
IMPORTANT: no threshold is prescribed for the laboratory exercises, but 30% of the total points make up a significant part of the
overall grade. That is why it is very important to work continuously and regularly access laboratory exercises.

On exam dates
For students who did not pass the exam during the continuous monitoring of classes, the total number of points received
by adding up the points obtained in the laboratory exercises during the continuous monitoring of classes and
points obtained on written tests of knowledge during the examination period
- total number of points = transferred number of lab points. see + number of points written knowledge test
Conditions for achieving a passing grade on the exam period:
- achieved a threshold of at least 35 (out of 70 possible) points on the written knowledge test and
- total number of points >= 50
Laboratory exercises carry a maximum of 30 points and have no point threshold.
The written knowledge test carries a maximum of 70 points and has a point threshold of 35 points.

2. Point thresholds for determining final grades
Students who meet the requirements for obtaining a passing grade based on continuous monitoring of classes
or at the exam period they receive a grade based on the following scale:
[87.5, 100] - grade 5
[75, 87.5) - grade 4
[62.5, 75) - grade 3
[50, 62.5) - grade 2


4. Other materials
1. Recommended literature
  - V. Mornar: Introduction to programming, Element, 2021.
     o The textbook covers the subject material. An integral part of the textbooks are about ninety
      of text-processed programs that can be independently translated and run in
      command line or in the VSCode development environment.
  - K. N. King, C Programming: A Modern Approach, Second Edition, W. W. Norton & Company
     o Extensive work (805 pages) which has been accepted as a textbook by hundreds of people
      universities in the world. About twenty copies of the book are available in the FER library.
  - B. W. Kernighan, D. M. Ritchie: The C Programming Language, Second Edition, Englewood
    Cliffs, NJ: Prentice Hall
     o Basic book whose authors are the creators of the C programming language from which they learned and learned the language
       many generations of programmers. Available in the FER library only for use in the reading room.

2. Instructions
- Instructions for translating programs written in the C programming language
   o contain a detailed description of software installation procedures and translation methods i
    program execution. Based on these instructions, students must learn elementary
    use one of the simple editors (Notepad or Notepad++) and translate programs
    using the command line of the operating system. Additionally, students using these
    instructions, they can, if they want, install and learn the basics of using integrated development
    environment of VSCode, in which it is much easier to detect errors because it is embedded
    simple interaction with a specialized program - a debugger.
- Instructions for using the character interface in the Windows operating system
   o the basics of using the character interface (command line) of the operating system.
    Based on these instructions, students are expected to independently learn a few there
    of the mentioned commands of the operating system: basics of positioning in folders
    file system, creation, renaming of files and folders, redirection
    entrances and exits.
- Instructions for laboratory exercises and the Edgar system


3. Official reminders
Official reminders can be printed on a printer and used freely in lectures and every check
knowledge: laboratory exercises, midterm exam, final exam and exam deadlines. To copies of official reminders that you will use at the checks
knowledge and laboratory exercises should not add anything.
- Official reminder for the C programming language -
   o a very useful tool with information that teachers think is missing
    need to learn by heart. It is recommended to use the official reminder in lectures
    and during independent work, in order to get acquainted with where and what information can be found
    to find, thus facilitating the use of reminders on knowledge checks
   o on a copy of the official reminder used in knowledge tests i
    nothing should be added to the laboratory exercises
    o this reminder will be available in digital form (pdf file) at the checks in
    to the Edgar system
- Official reminder for the gdb program
   o students who want to use the debugger, gdb, in the lab freely
    I can use this reminder
   o knowledge of working with the gdb program will not be required of the students, and the students themselves
    they decide if they want to use it


5. Lecturers and groups
Teachers Prof. Ph.D. Igor Mekterović and Izv. prof. Ph.D. Ljiljana Brkić gives lectures to group P1 in hall D1 in the time slot: Mon. 11-13 / Wednesday 10-12
Teachers Assoc. prof. Ph.D. Marina Bagić Babac and Prof. Ph.D. Gordan Gledec gives lectures to group P2 in hall D2 on the schedule: Mon. 11-13 / Wednesday 10-12
Teacher Assoc. Ph.D. Marko Horvat gives lectures to group P3 in hall B2 in the time slot: Mon. / Wednesday 8-10.
Teacher Prof. Ph.D. Nikica Hlupić gives lectures to group P4 in hall B3 in the time slot: Mon. / Wednesday 8-10.
Teacher Assoc. Ph.D. Slaven Zakošek gives lectures to group P5 in hall B2 in the time slot: Mon. / Wednesday 16-18.
Teachers Prof. Ph.D. Boris Vrdoljak and Prof. Ph.D. Krešimir Trontl gives lectures to group P6 in hall B3 in the time slot: Mon. 13-15 / Wednesday 14-16

6. Associates
- Boras, Bartol
- Dončević, Juraj
- Car, Mateja
- Fertalj, Melita
- Krajna, Agnesa
- Kvasic, Igor
- Marić, Petar
- Matijević, Mario
- Šarčević, Ana
- Palavra, Damir
- Vasiljević, Goran


7. Administration
Administration of the Institute for Applied Computing
- Sonja Majstorović
- sonja.majstorovic@fer.hr, building D, 3rd floor, phone: 6129-915

8. Communication by electronic mail
Ask questions related to the material to your teacher, and questions related to laboratory questions
send exercises to UPROlabosi@ferhr.onmicrosoft.com.
Communication by electronic mail between students and lecturers, assistants and administration must take place exclusively
through addresses @fer.hr, not e.g. @gmail.com,@yahoo.com and the like. At the beginning of the title (Subject) you should add the mark [UPRO] (which is
abbreviation of the name of the subject), and at the end state the name, surname and social security number of the sender.

9. Important links
- Home page of the subject
http://www.fer.hr/predmet/uup_a
- Folder with presentations from lectures
https://www.fer.unizg.hr/predmet/uup_a/materijali?@=2uem8#%23!p_rep_114391!_-195879
- Folder with assignments for exercises with lectures
https://www.fer.unizg.hr/predmet/uup_a/materijali#%23!p_rep_114391!_-195927
- Guide for students
https://www.fer.unizg.hr/_download/repository/UproVodicZaStudente.pdf
- Dates, topics and points in laboratory exercises
https://www.fer.unizg.hr/_download/repository/TerminiTemeBodoviLabVjezbe.pdf
- Instructions for translating programs written in the C programming language
https://www.fer.unizg.hr/_download/repository/UPROUPutePisanjePrograma.pdf
- Instructions for using the character interface in the Windows operating system
https://www.fer.unizg.hr/_download/repository/UPROUPuteZnakovnoSuceljeWindows.pdf
- Instructions for laboratory exercises and the Edgar system
https://www.fer.unizg.hr/_download/repository/UproUputeZaLabVjezbe.pdf
- Official reminder for the C programming language
https://www.fer.unizg.hr/_download/repository/PodsjetnikJezikC.pdf
- Official reminder for the gdb program
https://www.fer.unizg.hr/_download/repository/PodsjetnikDbg.pdf